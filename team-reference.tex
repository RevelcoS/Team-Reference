\documentclass[12pt, a4paper, dwarf]{article}

\usepackage[T1,T2A]{fontenc}     % форматы шрифтов
\usepackage[utf8x]{inputenc}     % кодировка символов, используемая в данном файле
\usepackage{mathtools}
\usepackage[english]{babel}      % пакет русификации
\usepackage{tikz}                % для создания иллюстраций
\usepackage{geometry}		     % для настройки размера полей
\usepackage{indentfirst}         % для отступа в первом абзаце секции

% \lstset{extendedchars=\true}
\geometry{a4paper,left=30mm,top=30mm,bottom=30mm,right=30mm}
\setlength{\headheight}{15pt}

\usepackage{fancyhdr}
\pagestyle{fancy}

% Clear default header/footer
\fancyhf{}

% Left header: Team name + authors
\fancyhead[L]{2pink (Grigorev Sergei, Grigorev Andrew, Shelomagin Fedor)}

% Right header: page number "Page X of Y"
\usepackage{lastpage}
\fancyhead[R]{Page \thepage\ of \pageref{LastPage}}

% Remove header line
\renewcommand{\headrulewidth}{0.4pt}

\begin{document}

\section*{Config}

\subsection*{template.cpp}

\begin{verbatim}

#include <bits/stdc++.h>

#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
#define pb(a, x) (a).push_back(x)

std::mt19937 rnd(std::chrono::steady_clock::now().time_since_epoch().count());

struct Hash {

    static uint64_t splitmix64(uint64_t x) {

        // http://xorshift.di.unimi.it/splitmix64.c
        x += 0x9e3779b97f4a7c15;
        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
        return x ^ (x >> 31);

    }

    size_t operator()(uint64_t x) const {

        static const uint64_t FIXED_RANDOM =
            std::chrono::steady_clock::now().time_since_epoch().count();

        return splitmix64(x + FIXED_RANDOM);

    }

};

using namespace std;

using ll = long long;
using ull = unsigned long long;

int main() {

    return 0;

}

\end{verbatim}

\newpage
\subsection*{vim}
\normalsize

\begin{verbatim}

" .vimrc

" Sets the default vim settings. 
source $VIMRUNTIME/defaults.vim

" Disables compatibility with vim
set nocompatible

" Enables type file detection
filetype on

" Enables plugins
filetype plugin on

" Enables indent region when entering new line
filetype indent on

" Enables syntax highlighting.
syntax on

" Enable colorsheme
colorscheme pancake

" Numbers lines of file
set number

" Status line
set laststatus=2
set statusline=%F

" Cursor
let &t_SI = "\e[5 q"
let &t_EI = "\e[1 q"

set guicursor=i:blinkwait50-blinkon50-blinkoff50

" Mode transition
set ttimeoutlen=10

" Don't carry comments on Enter
autocmd FileType * set formatoptions-=ro

" Key mappings
map <CR> o<ESC>

" Specifies tab and shift width
set shiftwidth=4
set tabstop=4
set softtabstop=0
set smarttab
set expandtab

" Encodings
set encoding=utf-8
set fileencodings=utf-8,cp1251

" Navigation with cursor
set mouse=a

" Copy to clipboard
set clipboard=unnamed

" Shows closed parantheses
set showmatch

" Use 256 colors set
set t_Co=256

""" SEARCH SETTINGS
" Smart case ignore
set ignorecase
set smartcase

" Search highlighting
set incsearch
set hlsearch

""" COMMANDS AND MODE SETTINGS
" Show input commands and current mode
set showcmd
set showmode

" Save commands in history
set history=1000

" Column
set colorcolumn=120

\end{verbatim}

\newpage
\section*{FFT}

\begin{verbatim}
// 998244353 = 1 + 7 * 17 * 2^23 = 1 + c * 2 ^ k
// Primitive root: r = 3
// w = r^c = 3^(7 * 17)
// w^(2^23) = 1

ll mod = 998244353LL;
constexpr ll mxN = 5e5L;

ll roots[32];
ll inv_roots[32];
ll fact[mxN + 1];

ll rootN = 23;

ll binpow(ll x, ll p) {

    ll res = 1;
    while (p > 0) {

        if (p & 1)
            res = res * x % mod;

        p >>= 1;
        x = x * x % mod;

    }

    return res;

}

ll inv(ll x) {
    return binpow(x, mod - 2);
}

ll reverse(ll num, int lgN) {

    ll res = 0;
    for (int i = 0; i < lgN; i++) {
        if (num & (1LL << i))
            res |= 1LL << (lgN - i - 1);
    }

    return res;

}

void precomp_roots() {

    roots[0] = binpow(3, 7 * 17);

    for (int i = 1; i <= rootN; i++) {
        roots[i] = roots[i-1] * roots[i-1] % mod;
    }

    inv_roots[0] = inv(roots[0]);
    for (int i = 1; i <= rootN; i++) {
        inv_roots[i] = inv_roots[i-1] * inv_roots[i-1] % mod;
    }

}

// const double PI = acos(-1);

void fft(vector<ll> &a, bool invert) {

    ll N = a.size();
    ll lgN = 0;
    while ((1 << lgN) < N)
        lgN++;

    for (int i = 0; i < N; i++) {
        int needI = reverse(i, lgN);
        if (i < needI)
            swap(a[i], a[needI]);
    }

    for (ll power = 1; power <= lgN; power++) {

        ll root = invert ? roots[rootN - power] : inv_roots[rootN - power];
        ll len = 1LL << power;

        // double ang = 2 * PI / len * (invert ? -1 : 1);
        // complex<double> root(cos(ang), sin(ang));

        for (ll i = 0; i < N; i += len) {

            ll w = 1;
            for (ll j = 0; j < (len >> 1); j++) {

                ll u = a[i + j];
                ll v = a[i + j + (len >> 1)] * w % mod;

                a[i + j] = (u + v) % mod;
                a[i + j + (len >> 1)] = (u - v + mod) % mod;

                w = w * root % mod;

            }

        }

    }

    if (invert) {

        ll invN = inv(N);
        for (ll i = 0; i < N; i++)
            a[i] = a[i] * invN % mod;

    }

}

void mult(vector<ll> &A, vector<ll> &B) {

    ll N = 1;
    while (N < A.size() + B.size())
        N <<= 1;

    A.resize(N);
    B.resize(N);

    fft(A, false);
    fft(B, false);
    for (ll i = 0; i < N; i++)
        A[i] = A[i] * B[i] % mod;

    fft(A, true);

    // vector<int> result(N);
    // for (int i = 0; i < N; i++)
    //    result[i] = round(A[i].real());

}

\end{verbatim}

\section*{Knapsack}

\subsection*{0-1 knapsack}

Can use each item only once.

$$f_{i,j} = \max(f_{i-1, j}, f_{i-1, j-w_i} + v_i)$$
$$f_j \leftarrow \max(f_j, f_{j-w_i} + v_i)$$
$$j = W \ldots w[i]$$

\begin{verbatim}

// C++
for (int i = 1; i <= n; i++)
    for (int j = W; j >= w[i]; j--)
        f[j] = max(f[j], f[j - w[i]] + v[i]);

\end{verbatim}

\subsection*{Complete knapsack}

Can use each item unlimited number of times.
$$f_{i, j} = \max_{k \ge 0}(f_{i-1, j-k \cdot w_i} + k \cdot v_i)$$

This is the same as:
$$f_{i, j} = \max(f_{i-1, j}, f_{i, j-w_i} + v_i)$$
$$f_j \leftarrow \max(f_j, f_{j-w_i} + v_i)$$
$$j = w[i] \ldots W$$

\normalsize
\begin{verbatim}

// C++
for (int i = 1; i <= n; i++)
  for (int j = w[i]; j <= W; j++)
    f[j] = max(f[j], f[j - w[i]] + v[i]);

\end{verbatim}

\newpage
\section*{Fenwick tree}

\normalsize
\begin{verbatim}
\\ C++

void update(int k, int delta) {

    while (k < mxN) {
        T[k] += delta;
        k = k | (k + 1);
    }

}

ll pref(int i) {

    ll sum = 0;
    while (i >= 0) {
        sum += T[i];
        i = i & (i + 1)
        i--;
    }
    return sum;

}

void build() {

    for (int k = 0; k < n; k++) {
        update(k, a[k]);
    }

}

void change(int k, int u) {

    int delta = u - a[k];
    a[k] = u;
    update(k, delta);

}

inline ll getsum(int l, int r) {

    return pref(r) - pref(l - 1);

}
\end{verbatim}

\newpage
\section*{Segment tree}

\begin{verbatim}

// C++

constexpr int mxN = 2e5L;
constexpr int inf = 2e9L;

int n;
int segsize;
int a[mxN];
int tree[2 * mxN];

int nextb(int x) {

    x |= (x >> 1);
    x |= (x >> 2);
    x |= (x >> 4);
    x |= (x >> 8);
    x |= (x >> 16);
    return x + 1;

}

void update(int k, int u) {

    int l = 0, r = segsize - 1;
    int index = 0;
    while (l < r) {

        int mid = (l + r) >> 1;
        if (k <= mid) {
            r = mid;
            index = 2 * index + 1;
        } else {
            l = mid + 1;
            index = 2 * index + 2;
        }

    }

    tree[index] = u;
    while (index > 0) {

        index = (index - 1) >> 1;
        tree[index] = min(tree[2 * index + 1], tree[2 * index + 2]);

    }

}

void build() {

    fill(tree, tree + 2 * mxN, inf);
    segsize = nextb(n - 1);

    for (int k = 0; k < n; k++) {
        update(k, a[k]);
    }

}

int getmin(int l, int r, int index, int size, int mid) {

    if (r - l + 1 == size)
        return tree[index];

    int off = size >> 2;

    if (l <= mid && mid < r)
        return min(getmin(l, mid, 2 * index + 1, size >> 1, mid - off),
                   getmin(mid + 1, r, 2 * index + 2, size >> 1, mid + off));

    if (r <= mid)
        return getmin(l, r, 2 * index + 1, size >> 1, mid - off);

    // l > mid
    return getmin(l, r, 2 * index + 2, size >> 1, mid + off);

}

int main() { 

    // int mn = getmin(l, r, 0, segsize, (segsize - 1) >> 1);
	return 0;

}

\end{verbatim}

\newpage
\section*{Dijkstra}

\begin{verbatim}
// C++

vector<int> dijkstra(int start) {
    vector<int> d(n, inf);
    d[start] = 0;
    set< pair<int, int> > q;
    q.insert({0, start});

    while (!q.empty()) {
        int v = q.begin()->second;
        q.erase(q.begin());

        for (auto [u, w] : g[v]) {

            if (d[u] > d[v] + w) {
                q.erase({d[u], u});
                d[u] = d[v] + w;
                q.insert({d[u], u});
            }

        }

    }
    return d;
}
\end{verbatim}

\section*{Prefix function}

\begin{verbatim}
// C++

vector<int> prefix_function(string s) {
    int n = (int) s.size();
    vector<int> p(n, 0);
    for (int i = 1; i < n; i++) {
        int cur = p[i - 1];

        while (s[i] != s[cur] && cur > 0)
            cur = p[cur - 1];

        if (s[i] == s[cur])
            p[i] = cur + 1;
    }
    return p;
}
\end{verbatim}

\newpage

\section*{Roman Numerals}

\begin{verbatim}
# Python
class RomanNumerals(object):

    letters = [('M',1000), ('CM',900),
                ('D',500), ('CD',400),
                ('C',100), ('XC',90),
                ('L',50), ('XL',40),
                ('X',10), ('IX',9),
                ('V',5), ('IV',4),
                ('I',1)]
    
    @classmethod
    def to_roman(cls, val):
        rom = []
        for l, v in cls.letters:
            m = val // v
            rom += m*[l]
            val -= m*v
        return ''.join(rom)
        
    @classmethod
    def from_roman(cls, rom):
        cumu = 0
        for l, v in cls.letters:
            while rom[:len(l)] == l:
                rom = rom[len(l):]
                cumu += v
            if not rom: break
        return cumu
\end{verbatim}

\section*{Euclid}

\begin{verbatim}
#Python

def ext_euclid(a, b):
    if b == 0:
        return a, 1, 0

    d, xx, yy = ext_euclid(b, a % b)
    x = yy
    y = xx - (a / b) * yy
    return d, x, y

\end{verbatim}

\section*{Rho-Pollard}

\begin{verbatim}
// C++

long long mult(long long a, long long b, long long mod) {
    return (__int128)a * b % mod;
}

// OR
long long mult(long long a, long long b, long long mod) {
    long long result = 0;
    while (b) {
        if (b & 1)
            result = (result + a) % mod;
        a = (a + a) % mod;
        b >>= 1;
    }
    return result;
}

long long f(long long x, long long c, long long mod) {
    return (mult(x, x, mod) + c) % mod;
}

long long rho(long long n, long long x0=2, long long c=1) {
    long long x = x0;
    long long y = x0;
    long long g = 1;
    while (g == 1) {
        x = f(x, c, n);
        y = f(y, c, n);
        y = f(y, c, n);
        g = gcd(abs(x - y), n);
    }
    return g;
}
\end{verbatim}

\section*{Convex Hull}

\begin{verbatim}
struct pt {
    double x, y;
    bool operator == (pt const& t) const {
        return x == t.x && y == t.y;
    }
};

int orientation(pt a, pt b, pt c) {
    double v = a.x*(b.y-c.y)+b.x*(c.y-a.y)+c.x*(a.y-b.y);
    if (v < 0) return -1; // clockwise
    if (v > 0) return +1; // counter-clockwise
    return 0;
}

bool cw(pt a, pt b, pt c, bool include_collinear) {
    int o = orientation(a, b, c);
    return o < 0 || (include_collinear && o == 0);
}
bool collinear(pt a, pt b, pt c) { return orientation(a, b, c) == 0; }

void convex_hull(vector<pt>& a, bool include_collinear = false) {
    pt p0 = *min_element(a.begin(), a.end(), [](pt a, pt b) {
        return make_pair(a.y, a.x) < make_pair(b.y, b.x);
    });
    sort(a.begin(), a.end(), [&p0](const pt& a, const pt& b) {
        int o = orientation(p0, a, b);
        if (o == 0)
            return (p0.x-a.x)*(p0.x-a.x) + (p0.y-a.y)*(p0.y-a.y)
                < (p0.x-b.x)*(p0.x-b.x) + (p0.y-b.y)*(p0.y-b.y);
        return o < 0;
    });
    if (include_collinear) {
        int i = (int)a.size()-1;
        while (i >= 0 && collinear(p0, a[i], a.back())) i--;
        reverse(a.begin()+i+1, a.end());
    }

    vector<pt> st;
    for (int i = 0; i < (int)a.size(); i++) {
        while (st.size() > 1 &&
               !cw(st[st.size()-2], st.back(), a[i], include_collinear))
            st.pop_back();
        st.push_back(a[i]);
    }

    if (include_collinear == false && st.size() == 2 && st[0] == st[1])
        st.pop_back();

    a = st;
}
\end{verbatim}

\end{document}
